(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{571:function(a,t,r){"use strict";r.r(t);var s=r(30),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("iframe",{staticStyle:{display:"block",width:"100%",height:"300px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/628d80f70791291ba2fe8200"}}),a._v(" "),r("h2",{attrs:{id:"_1-什么是并发-什么是并行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是并发-什么是并行"}},[a._v("#")]),a._v(" 1. 什么是并发？什么是并行？")]),a._v(" "),r("p",[a._v("并发和并行的目标都是最大化 CPU 的使用率。")]),a._v(" "),r("p",[r("strong",[a._v("并行")]),a._v("：指在同一时刻，有多条指令在多个处理器上同时执行。无论从微观还是宏观来看，二者都是一起执行的。")]),a._v(" "),r("p",[r("strong",[a._v("并发")]),a._v("：指在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，使得从宏观上具有多个进程同时执行的效果，但是微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替地执行。")]),a._v(" "),r("p",[a._v("并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在。并发能够在单处理器系统中存在使因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作(每个小时间片执行一个操作，多个操作快速切换执行)。")]),a._v(" "),r("h2",{attrs:{id:"_3-进程、线程、协程的区别是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程、线程、协程的区别是什么"}},[a._v("#")]),a._v(" 3. 进程、线程、协程的区别是什么？")]),a._v(" "),r("h2",{attrs:{id:"_4-为什么要使用多线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么要使用多线程"}},[a._v("#")]),a._v(" 4. 为什么要使用多线程?")]),a._v(" "),r("h2",{attrs:{id:"_5-说说线程的生命周期。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-说说线程的生命周期。"}},[a._v("#")]),a._v(" 5. 说说线程的生命周期。")]),a._v(" "),r("h2",{attrs:{id:"_6-进程间通信有几种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-进程间通信有几种方式"}},[a._v("#")]),a._v(" 6. 进程间通信有几种方式？")]),a._v(" "),r("h2",{attrs:{id:"_7-线程间通信有几种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-线程间通信有几种方式"}},[a._v("#")]),a._v(" 7. 线程间通信有几种方式？")]),a._v(" "),r("h2",{attrs:{id:"_8-什么是-java-内存模型-jmm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-什么是-java-内存模型-jmm"}},[a._v("#")]),a._v(" 8. 什么是 Java 内存模型(JMM)?")]),a._v(" "),r("h2",{attrs:{id:"_9-java-创建线程有几种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-java-创建线程有几种方式"}},[a._v("#")]),a._v(" 9. Java 创建线程有几种方式？")]),a._v(" "),r("h2",{attrs:{id:"_10-volatile-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-volatile-的实现原理是什么"}},[a._v("#")]),a._v(" 10. volatile 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_11-什么是伪共享-怎么避免伪共享"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么是伪共享-怎么避免伪共享"}},[a._v("#")]),a._v(" 11. 什么是伪共享？怎么避免伪共享？")]),a._v(" "),r("h2",{attrs:{id:"_12-synchronized-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-synchronized-的实现原理是什么"}},[a._v("#")]),a._v(" 12. synchronized 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_13-请谈谈-synchronized-锁升级的过程。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_13-请谈谈-synchronized-锁升级的过程。"}},[a._v("#")]),a._v(" 13. 请谈谈 synchronized 锁升级的过程。")]),a._v(" "),r("h2",{attrs:{id:"_14-请对比下-volatile-和-synchronized-的异同。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_14-请对比下-volatile-和-synchronized-的异同。"}},[a._v("#")]),a._v(" 14. 请对比下 volatile 和 synchronized 的异同。")]),a._v(" "),r("h2",{attrs:{id:"_15-jvm-对-java-原生锁做了哪些优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_15-jvm-对-java-原生锁做了哪些优化"}},[a._v("#")]),a._v(" 15. JVM 对 Java 原生锁做了哪些优化？")]),a._v(" "),r("h2",{attrs:{id:"_16-synchronized-和-lock-有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-synchronized-和-lock-有什么区别"}},[a._v("#")]),a._v(" 16. synchronized 和 Lock 有什么区别？")]),a._v(" "),r("h2",{attrs:{id:"_17-谈谈你对-aqs-的理解。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-谈谈你对-aqs-的理解。"}},[a._v("#")]),a._v(" 17. 谈谈你对 AQS 的理解。")]),a._v(" "),r("h2",{attrs:{id:"_18-countdownlatch-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_18-countdownlatch-的实现原理是什么"}},[a._v("#")]),a._v(" 18. CountDownLatch 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_19-cyclicbarrier-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_19-cyclicbarrier-的实现原理是什么"}},[a._v("#")]),a._v(" 19. CyclicBarrier 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_20-countdownlatch-和-cyclicbarrier-的区别是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_20-countdownlatch-和-cyclicbarrier-的区别是什么"}},[a._v("#")]),a._v(" 20. CountDownLatch 和 CyclicBarrier 的区别是什么？")]),a._v(" "),r("h2",{attrs:{id:"_21-reentrantlock-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_21-reentrantlock-的实现原理是什么"}},[a._v("#")]),a._v(" 21. ReentrantLock 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_22-reentrantlock-是如何实现可重入的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-reentrantlock-是如何实现可重入的"}},[a._v("#")]),a._v(" 22. ReentrantLock 是如何实现可重入的？")]),a._v(" "),r("h2",{attrs:{id:"_23-reentrantreadwritelock-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_23-reentrantreadwritelock-的实现原理是什么"}},[a._v("#")]),a._v(" 23. ReentrantReadWriteLock 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_24-semaphore-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_24-semaphore-的实现原理是什么"}},[a._v("#")]),a._v(" 24. Semaphore 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_25-阻塞队列的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_25-阻塞队列的实现原理是什么"}},[a._v("#")]),a._v(" 25. 阻塞队列的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_26-怎么选择合适的阻塞队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_26-怎么选择合适的阻塞队列"}},[a._v("#")]),a._v(" 26. 怎么选择合适的阻塞队列？")]),a._v(" "),r("h2",{attrs:{id:"_27-locksupport-与-wait-notify-的区别是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_27-locksupport-与-wait-notify-的区别是什么"}},[a._v("#")]),a._v(" 27. LockSupport 与 wait/notify 的区别是什么？")]),a._v(" "),r("h2",{attrs:{id:"_28-有a、b、c三个线程-如果保证三个线程同时执行-如果在并发情况下保证三个线程依次执行-如何保证三个线程有序交错执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_28-有a、b、c三个线程-如果保证三个线程同时执行-如果在并发情况下保证三个线程依次执行-如何保证三个线程有序交错执行"}},[a._v("#")]),a._v(" 28. 有A、B、C三个线程，如果保证三个线程同时执行？如果在并发情况下保证三个线程依次执行？如何保证三个线程有序交错执行？")]),a._v(" "),r("h2",{attrs:{id:"_29-什么是线程安全-怎么保证线程安全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_29-什么是线程安全-怎么保证线程安全"}},[a._v("#")]),a._v(" 29. 什么是线程安全，怎么保证线程安全?")]),a._v(" "),r("h2",{attrs:{id:"_30-interrupt-、isinterrupted-、interrupted-方法有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_30-interrupt-、isinterrupted-、interrupted-方法有什么区别"}},[a._v("#")]),a._v(" 30. interrupt()、isInterrupted()、interrupted()方法有什么区别？")]),a._v(" "),r("h2",{attrs:{id:"_31-如何优雅地停止一个线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_31-如何优雅地停止一个线程"}},[a._v("#")]),a._v(" 31. 如何优雅地停止一个线程？")]),a._v(" "),r("h2",{attrs:{id:"_32-wait-、sleep-、yield-、join-方法的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_32-wait-、sleep-、yield-、join-方法的区别"}},[a._v("#")]),a._v(" 32. wait()、sleep()、yield()、join() 方法的区别？")]),a._v(" "),r("h2",{attrs:{id:"_33-为什么-wait-方法、notify-方法一定要在同步代码块或者同步方法中调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_33-为什么-wait-方法、notify-方法一定要在同步代码块或者同步方法中调用"}},[a._v("#")]),a._v(" 33. 为什么 wait() 方法、notify() 方法一定要在同步代码块或者同步方法中调用？")]),a._v(" "),r("h2",{attrs:{id:"_34-什么是死锁-怎么避免死锁-怎么解决死锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_34-什么是死锁-怎么避免死锁-怎么解决死锁"}},[a._v("#")]),a._v(" 34. 什么是死锁？怎么避免死锁？怎么解决死锁？")]),a._v(" "),r("h2",{attrs:{id:"_35-为什么要使用线程池"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_35-为什么要使用线程池"}},[a._v("#")]),a._v(" 35. 为什么要使用线程池？")]),a._v(" "),r("h2",{attrs:{id:"_36-线程池的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_36-线程池的实现原理是什么"}},[a._v("#")]),a._v(" 36. 线程池的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_37-线程池是为什么能实现线程复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_37-线程池是为什么能实现线程复用"}},[a._v("#")]),a._v(" 37. 线程池是为什么能实现线程复用？")]),a._v(" "),r("h2",{attrs:{id:"_38-线程池中的线程是怎么创建的-是一开始就随着线程池的启动创建好的吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_38-线程池中的线程是怎么创建的-是一开始就随着线程池的启动创建好的吗"}},[a._v("#")]),a._v(" 38. 线程池中的线程是怎么创建的，是一开始就随着线程池的启动创建好的吗？")]),a._v(" "),r("h2",{attrs:{id:"_39-项目中一般怎么设置线程池参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_39-项目中一般怎么设置线程池参数"}},[a._v("#")]),a._v(" 39. 项目中一般怎么设置线程池参数?")]),a._v(" "),r("h2",{attrs:{id:"_40-高并发、任务执行时间短的业务怎么设置线程池参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_40-高并发、任务执行时间短的业务怎么设置线程池参数"}},[a._v("#")]),a._v(" 40. 高并发、任务执行时间短的业务怎么设置线程池参数？")]),a._v(" "),r("h2",{attrs:{id:"_41-并发不高、任务执行时间长的业务怎么设置线程池参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_41-并发不高、任务执行时间长的业务怎么设置线程池参数"}},[a._v("#")]),a._v(" 41. 并发不高、任务执行时间长的业务怎么设置线程池参数？")]),a._v(" "),r("h2",{attrs:{id:"_42-并发高、执行任务时间长的业务怎么设置线程池参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_42-并发高、执行任务时间长的业务怎么设置线程池参数"}},[a._v("#")]),a._v(" 42. 并发高、执行任务时间长的业务怎么设置线程池参数？")]),a._v(" "),r("h2",{attrs:{id:"_43-线程池中阻塞队列的作用-为什么是先添加任务到队列中而不是优先创建线程执行任务-有没有例外的情况-tomcat-线程池为什么优先创建线程来处理请求而不是先把请求添加到队列中-怎么实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_43-线程池中阻塞队列的作用-为什么是先添加任务到队列中而不是优先创建线程执行任务-有没有例外的情况-tomcat-线程池为什么优先创建线程来处理请求而不是先把请求添加到队列中-怎么实现的"}},[a._v("#")]),a._v(" 43. 线程池中阻塞队列的作用？为什么是先添加任务到队列中而不是优先创建线程执行任务？有没有例外的情况？Tomcat 线程池为什么优先创建线程来处理请求而不是先把请求添加到队列中？怎么实现的？")]),a._v(" "),r("h2",{attrs:{id:"_44-定时任务线程池的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_44-定时任务线程池的实现原理是什么"}},[a._v("#")]),a._v(" 44. 定时任务线程池的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_45-cas-的实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_45-cas-的实现原理是什么"}},[a._v("#")]),a._v(" 45. CAS 的实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_46-double-check-lock-实现的单例模式为什么要用-volatile"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_46-double-check-lock-实现的单例模式为什么要用-volatile"}},[a._v("#")]),a._v(" 46. Double Check Lock 实现的单例模式为什么要用 volatile ?")]),a._v(" "),r("h2",{attrs:{id:"_47-threadlocal-的底层实现原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_47-threadlocal-的底层实现原理是什么"}},[a._v("#")]),a._v(" 47. ThreadLocal 的底层实现原理是什么？")]),a._v(" "),r("h2",{attrs:{id:"_48-threadlocal-有什么缺陷-提交异步任务到线程池时-如何给异步线程传递值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_48-threadlocal-有什么缺陷-提交异步任务到线程池时-如何给异步线程传递值"}},[a._v("#")]),a._v(" 48. ThreadLocal 有什么缺陷？提交异步任务到线程池时，如何给异步线程传递值？")])])}),[],!1,null,null,null);t.default=e.exports}}]);