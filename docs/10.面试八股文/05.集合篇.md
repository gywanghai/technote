---
title: 集合篇
date: 2022-05-07 15:22:17
permalink: /interview/collection/
categories:
  - 面试八股文
tags:
  - 
author: 
  name: 二师兄
  link: https://github.com/gywanghai
---

## 1. ArrayList 和 LinkedList 有什么区别?

ArrayList 底层数据结构是数组，数组支持按下标随机访问数组中的元素，平均时间复杂度为 O(1)；数组在尾部添加、删除元素的平均时间复杂度为O(1)，在其他位置添加、删除元素需要移动下标位置之后的元素，平均时间复杂度为 O(n)；ArrayList 在添加元素时如果发现数组剩余空间不足，会先进行扩容。扩容时，先创建一个新的数组，新数组容量是旧数组容量的1.5倍，然后把数组中的元素一一拷贝到新的数组中。由于扩容需要把数组元素从旧数组拷贝到新数组中，会有一定的性能损耗。

LinkedList 底层数据结构是链表，链表不支持随机访问，查找元素需要从链表的第一个元素开始进行遍历，平均时间复杂度为 O(n)；指定位置插入、删除元素的平均时间复杂度为 O(1)；链表不需要连续的内存空间，所以不需要扩容。但是链表节点除了存储元素数据以外，还需要存储指向下一个节点的指针信息，有额外的内存开销。

## 2. ArrayList是怎么扩容的？

1. 检查是否需要扩容。
2. 计算新容量，是旧容量的1.5倍 (oldCapacity + oldCapacity >> 1)，如果发现新容量比实际需要的容量还小，则以需要的容量为准。
3. 创建新容量的数组并把旧数组的元素拷贝到新数组。

## 3. ArrayList 插入、删除、查询元素的时间复杂度各是多少？

1. 尾部插入、删除元素的平均时间复杂度为 O(1); 其他位置插入、删除元素的平均时间复杂度为 O(n)。
2. 随机查询元素的时间复杂度为 O(1)。

## 4. 怎么求两个集合的并集、交集、差集？

1. ArrayList 支持求并集，调用 addAll(Collection c)方法即可。
2. ArrayList 支持求交集，调用 retainAll(Collection c)方法即可。
3. ArrayList 支持求差集，调用 removeAll(Collection c)方法即可。

## 5. ArrayList 是怎么实现序列化和反序列化的？

ArrayList 实现了 Serializable 接口，在 writeObject() 方法中先调用了 s.defaultWriteObject(java.io.ObjectOutputStream s) 方法，写入非 transient 的属性，也就是 size 属性；同样地，在 readObject(java.io.ObjectOutputStream s) 方法中先调用了 s.defaultReadObject() 方法解析出了 size 属性。 elementData 定义为transient 的优势，自己根据 size 序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。

## 6. ArrayList 的方法 toArray() 有什么问题？

ArrayList 的 toArray() 方法返回值是 Object[]，ArrayList 的 子类可重写 toArray() 方法，返回值类型可以和父类的不一样。如果子类的返回值不是Object[]，拷贝元素时需要重新拷贝成 Object[].class 类型。

## 7. 什么是 Fail-Fast？

Fail-Fast，快速失败，集合的一种错误机制，当使用迭代器迭代时，如果发现集合有修改，则快速失败做出响应，抛出ConcurrentModificationException。

支持 Fail-Fast 机制的集合类有一个成员变量 modCount，在添加、删除元素时，modCount 会自增加 1。使用迭代器遍历前会将迭代器的成员变量 expectedModCount 的值设置为 该集合当前 modCount 的值，遍历过程中如果检测到 modCount 的值发生了改变 ，就意味着该集合发生了修改，此时就会快速失败抛出ConcurrentModificationException。

哪些集合支持Fail-Fast?
- ArrayList
- HashSet
- HashMap

## 8. LinkedList是单链表还是双链表实现的？

LinkedList 是一个以双向链表实现的 List，不仅实现了List 接口，还实现了 Queue 和 Deque接口，所以可以作为队列(双端队列)或者栈来使用。

## 9. LinkedList是单链表还是双链表实现的？

LinkedList 是一个以双向链表实现的 List，不仅实现了List 接口，还实现了 Queue 和 Deque接口，所以可以作为队列(双端队列)或者栈来使用。

## 10. LinkedList 除了作为 List 还有什么用处？

LinkedList 是一个以双向链表实现的 List，不仅实现了List 接口，还实现了 Queue 和 Deque接口，所以还可以作为队列(双端队列)或者栈来使用。

## 11. LinkedList 插入、删除、查询元素的时间复杂度各是多少？

1. 尾部插入、删除元素的平均时间复杂度为O(1)，中间位置插入、删除元素需要通过遍历才能找到插入、删除元素的位置，平均时间复杂度为O(n)。
2. 查询元素的平均复杂度为O(n)。

## 12. 什么是随机访问？

查询指定元素不用从头开始向尾部遍历，可以直接通过计算得到目标元素存储的位置，直接从那个存储单元中读取到指定的元素。

## 13. 哪些集合支持随机访问？它们都有哪些共性？

支持随机访问的集合有：ArrayList，CopyOnWriteArrayList。它们都实现了 RandomAccess 接口。

## 14. CopyOnWriteArrayList 是怎么保证并发安全的?

CopyOnWriteArrayList 是 ArrayList 的线程安全版本。对于写操作，CopyOnWriteArrayList 将所有元素复制到一个新的数组中，在新的数组中进行操作，然后将元素数组的引用指向新的数组，这个过程中会使用 ReentrantLock 进行加锁，保证并发处理写请求的线程安全；底层的 Object 数组 array 是真正存储元素的地方，array用 volatile 修饰，保证一个线程对 array 的修改对另外一个线程可见；对于读操作，仍然从旧的数组中进行读取。这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。但是读操作可能会读到旧的数据，所以 CopyOnWriteArrayList 只能保证数据的最终一致性，不能保证数据的实时一致性。

## 15. CopyOnWriteArrayList 的实现采用了什么思想？

CopyOnWriteArrayList 的实现采用了写时复制和读写分离的思想。对于写操作，CopyOnWriteArrayList 将所有元素复制到一个新的数组中，在新的数组中进行操作，然后将元素数组的引用指向新的数组，这个过程中会使用 ReentrantLock 进行加锁，保证并发处理写请求的线程安全；底层的 Object 数组 array 是真正存储元素的地方，array用 volatile 修饰，保证一个线程对 array 的修改对另外一个线程可见；对于读操作，仍然从旧的数组中进行读取。这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。但是读操作可能会读到旧的数据，所以 CopyOnWriteArrayList 只能保证数据的最终一致性，不能保证数据的实时一致性。

## 16. CopyOnWriteArrayList 是不是强一致性的？

CopyOnWriteArrayList 的实现采用了写时复制和读写分离的思想。对于写操作，CopyOnWriteArrayList 将所有元素复制到一个新的数组中，在新的数组中进行操作，然后将元素数组的引用指向新的数组；对于读操作，仍然从旧的数组中进行读取。这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。但是读操作可能会读到旧的数据，所以 CopyOnWriteArrayList 只能保证数据的最终一致性，不能保证数据的实时一致性。 

## 17. CopyOnWriteArrayList 适用于什么样的场景？

CopyOnWriteArrayList 适用于读多写少、且能容忍短暂时间内数据不一致的场景。

原因：CopyOnWriteArrayList 的实现采用了写时复制和读写分离的思想。对于写操作，CopyOnWriteArrayList 将所有元素复制到一个新的数组中，在新的数组中进行操作，然后将元素数组的引用指向新的数组；对于读操作，仍然从旧的数组中进行读取。这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。但是读操作可能会读到旧的数据，所以 CopyOnWriteArrayList 只能保证数据的最终一致性，不能保证数据的实时一致性。 

## 18. CopyOnWriteArrayList 插入、删除、查询元素的时间复杂度各是多少？

CopyOnWriteArrayList 尾部插入元素的平均时间复杂度为 O(1)，其他位置插入元素的平均时间复杂度为 O(n)。

CopyOnWriteArrayList 尾部插入元素的平均时间复杂度为 O(1)，其他位置删除元素的平均时间复杂度为 O(n)。

CopyOnWriteArrayList 按索引查询元素的平均时间复杂度为 O(1)。


## 19. CopyOnWriteArrayList 为什么没有 size 属性？

每次修改都是新建一份正好可以存储目标个数元素的数组，并进行数据拷贝，数组的长度就是集合的大小，所以不需要 size 属性。 

## 20. 什么是散列表？

散列表是一种数据结构，根据散列算法将 key 转化为数组的下标值，并把该元素存放在数组中的下标位置处，根据指定 key 查询时，按照相同的散列算法计算出 key 对应的数组下标值，到数组的下标位置处看该位置是否存在元素，如果存在而且元素对应的 key 与需要查询的 key 相等，就返回该元素。添加元素时，不同的 key 计算出来的下标值可能相同，这样就会产生冲突，解决这种冲突有 3 种常见的方法：拉链法、开放寻址法、再哈希法。

拉链法，是指发生冲突时，在数组指定下标位置处存放的是一个链表，就把要添加的元素加入到链表中，查询时如果数组下标位置处是一个链表，则遍历链表，查询目标 key 对应的元素是否在链表中。

开放寻址法，是指发生冲突时，则从该位置向后开始寻找，看能否找到一个没有元素的位置，如果存在，则把目标元素存放在数组的指定下标位置。

再哈希法，是指发生冲突时，根据其他的散列算法计算元素在数组中的存放位置。直到找到一个没有元素的位置，如果找到，则把目标元素存放在数组的指定下标位置。

## 21. 怎么实现一个散列表？


## 22. Java 1.8 对 HashMap 实现方式做了哪些改进？

## 23. HashMap 的容量有什么特点？

## 24. HashMap是怎么进行扩容的？

## 25. HashMap中的元素是否是有序的？

## 26. HashMap 何时进行树化？何时进行反树化？为什么要这么设计？

## 27. HashMap 插入、删除、查询元素的时间复杂度各是多少？

## 28. HashMap 中的红黑树实现部分可以用其他的数据结构代替吗？

## 29. LinkedHashMap 是怎么实现的？

## 30. LinkedHashMap 是有序的吗？怎么个有序法？

## 31. LinkedHashMap 如何实现 LRU 缓存淘汰策略？

## 32. WeakHashMap 底层数据结构是什么？

## 33. WeakHashap 具有什么特性？通常用来做什么？

## 34. WeakHashMap 使用 String 作为 key 时需要注意什么？为什么？

## 35. 什么是弱引用？

## 36. 红黑树具有哪些特性？

## 37. TreeMap 是有序的吗？怎么个有序法？

## 38. TreeMap 是否需要扩容？

## 39. TreeMap 是什么遍历的？

## 40. TreeMap 插入、删除、查询元素的时间复杂度是多少？

## 41. HashMap 在多线程环境中什么时候会出现问题？

## 42. ConcurrentHashMap 的 底层存储结构是什么？

## 43. ConcurrentHashMap 是怎么保证并发安全的？

## 44. ConcurrentHashMap 是怎么扩容的？

## 45. ConcurrentHashMap 的 size() 方法是怎么实现的？

## 46. ConcurrentHashMap 是强一致性的吗？

## 47. ConcurrentHashMap 哪些地方运用到了分段锁的思想？

## 48. 什么是伪共享？怎么避免伪共享？

## 49. 什么是跳表？

## 50. ConcurrentSkipList 是有序的吗？

## 51. ConcurrentSkipList 是如何保证线程安全的？

## 52. ConcurrentSkipList 插入、删除、查询元素的时间复杂度各是多少？

## 53. ConcurrentSkipList 的索引具有什么特性？

## 54. 为什么Redis 选择跳表而不是红黑树来实现有序集合？




